const { supabase } = require('../model/database');
const userController = require('./userController');
const { validateReserveForName, logValidationFailure } = require('../utils/validation');


exports.reserveASeat = async (req, res) => {
    try {
        const { seatNumber, date, start_time, end_time } = req.body;
        const labName = req.params.labName;
        const username = req.session.username;

        if (!username) {
            return res.status(401).json({ message: "User not authenticated" });
        }

        // First, get the user's UUID from their username
        const { data: user, error: userError } = await supabase
            .from('users')
            .select('id')
            .eq('username', username)
            .single();

        if (userError) {
            console.error("Database error finding user:", userError);
            return res.status(500).json({ message: "Database error finding user" });
        }

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        // Find the lab document by its name (A, B, C)
        const { data: lab, error: labError } = await supabase
            .from('lab')
            .select('*')
            .eq('lab_name', labName) // labName contains the lab name (A, B, C)
            .single();

        if (labError) {
            console.error("Database error finding lab:", labError);
            return res.status(500).json({ message: "Database error finding lab" });
        }

        if (!lab) {
            return res.status(404).json({ message: "Lab not found", labName });
        }

        // Get the seat information to get the seat_num
        const { data: seat, error: seatError } = await supabase
            .from('lab_seats')
            .select('*')
            .eq('id', seatNumber)
            .single();

        if (seatError) {
            console.error("Database error finding seat:", seatError);
            return res.status(500).json({ message: "Database error finding seat" });
        }

        if (!seat) {
            return res.status(404).json({ message: "Seat not found" });
        }

        // Check if the seat is available for reservation
        const { data: overlappingReservations, error: checkError } = await supabase
            .from('reservation')
            .select('id, date_of_reservation, start_time, end_time')
            .eq('lab_ID', lab.id)
            .eq('seat_ID', seatNumber)
            .eq('date_of_reservation', date)
            .or(`start_time.lt.${end_time},end_time.gt.${start_time}`);

        if (checkError) {
            console.error("Error checking overlapping reservations:", checkError);
            return res.status(500).json({ message: "Error checking seat availability" });
        }

        if (overlappingReservations && overlappingReservations.length > 0) {
            return res.status(409).json({ message: "Seat is already reserved for the specified time slot" });
        }

        // Note: We no longer check is_available in lab_seats table
        // Seat availability is now managed purely through the reservation table

        // Create a new reservation with all required fields
        const newReservation = {
            date_of_reservation: date,
            start_time,
            end_time,
            lab_ID: lab.id,
            lab_name: lab.lab_name, // Add the lab name (A, B, C)
            reserved_by_user_id: user.id, // Use the actual UUID from users table
            reserved_by: username, // Store username for display purposes
            seat_ID: parseInt(seatNumber),
            seat_num: seat.seat_num // Use the seat_num directly from lab_seats table
            // created_at will be auto-generated by Supabase
        };

        // Insert the reservation
        const { data: insertedReservation, error: insertError } = await supabase
            .from('reservation')
            .insert([newReservation])
            .select();

        if (insertError) {
            console.error("Error inserting reservation:", insertError);
            console.error("Insert error details:", {
                code: insertError.code,
                message: insertError.message,
                details: insertError.details,
                hint: insertError.hint
            });
            return res.status(500).json({ message: "Error creating reservation" });
        }
        
        // Note: We no longer update is_available in lab_seats table
        // Seat availability is now managed purely through the reservation table
        
        return res.status(201).json({ message: "Reservation successful" });
    } catch (e) {
        console.error("Error occurred while reserving seat:", e);
        return res.status(500).json({ message: "Internal server error" });
    }
};

exports.adminReserve = async (req, res) => {
    try {
        console.log('Request body:', req.body);
        console.log('Request params:', req.params);
        
        const { seatNumber, date, start_time, end_time, user_name } = req.body;
        const labName = req.params.labName;

        console.log('Extracted data:', { seatNumber, date, start_time, end_time, user_name, labName });

        if (!user_name) {
            return res.status(400).json({ message: "Username is required for admin reservation" });
        }

        // Validate the "reserve for" name field
        console.log('Starting validation for user_name:', user_name);
        const validationResult = validateReserveForName(user_name);
        console.log('Validation result:', validationResult);
        if (!validationResult.isValid) {
            console.log('Validation failed for input:', user_name);
            console.log('Validation error:', validationResult.message);
            
            // Try to log the validation failure, but don't fail the request if logging fails
            try {
                // Get the current admin user's ID from the session
                console.log('Getting current admin user ID for logging...');
                const { data: adminUser, error: adminUserError } = await supabase
                    .from('users')
                    .select('id')
                    .eq('username', req.session.username)
                    .single();

                if (!adminUserError && adminUser && adminUser.id) {
                    // Log the validation failure
                    console.log('Logging validation failure...');
                    console.log('Admin user ID for logging:', adminUser.id);
                    const logResult = await logValidationFailure(
                        supabase,
                        adminUser.id,
                        req.session.username,
                        'reserve_for',
                        user_name,
                        validationResult.message
                    );
                    
                    if (logResult.success) {
                        console.log('✅ Validation failure logged successfully');
                    } else {
                        console.error('❌ Failed to log validation failure:', logResult.error);
                    }
                } else {
                    console.error('Could not get admin user for logging:', adminUserError);
                    console.error('Admin user data:', adminUser);
                }
            } catch (loggingError) {
                console.error('Exception during validation failure logging:', loggingError);
            }
            
            // Return the validation error regardless of logging success
            return res.status(400).json({ message: validationResult.message });
        }

        console.log('Admin reservation proceeding for user:', user_name);
        console.log('Found admin user:', adminUser);

        // Find the lab document by its name (A, B, C)
        console.log('Fetching lab from database...');
        const { data: lab, error: labError } = await supabase
            .from('lab')
            .select('*')
            .eq('lab_name', labName) // labName contains the lab name (A, B, C)
            .single();

        if (labError) {
            console.error("Database error finding lab:", labError);
            return res.status(500).json({ message: "Database error finding lab" });
        }

        if (!lab) {
            return res.status(404).json({ message: "Lab not found", labName });
        }

        console.log('Found lab:', lab);

        // Get the seat information to get the seat_num
        console.log('Fetching seat information...');
        const { data: seat, error: seatError } = await supabase
            .from('lab_seats')
            .select('*')
            .eq('id', seatNumber)
            .single();

        if (seatError) {
            console.error("Database error finding seat:", seatError);
            return res.status(500).json({ message: "Database error finding seat" });
        }

        if (!seat) {
            return res.status(404).json({ message: "Seat not found" });
        }

        console.log('Found seat:', seat);

        // Check if the seat is available for reservation
        console.log('Checking for overlapping reservations...');
        const { data: overlappingReservations, error: checkError } = await supabase
            .from('reservation')
            .select('id, date_of_reservation, start_time, end_time')
            .eq('lab_ID', lab.id)
            .eq('seat_ID', seatNumber)
            .eq('date_of_reservation', date)
            .or(`start_time.lt.${end_time},end_time.gt.${start_time}`);

        if (checkError) {
            console.error("Error checking overlapping reservations:", checkError);
            return res.status(500).json({ message: "Error checking seat availability" });
        }

        console.log('Overlapping reservations check result:', overlappingReservations);

        if (overlappingReservations && overlappingReservations.length > 0) {
            return res.status(409).json({ message: "Seat is already reserved for the specified time slot" });
        }

        // Note: We no longer check is_available in lab_seats table
        // Seat availability is now managed purely through the reservation table

        // Create a new reservation with all required fields
        // For admin reservations, we can use any name in reserved_by and set reserved_by_user_id to a default value
        const newReservation = {
            date_of_reservation: date,
            start_time,
            end_time,
            lab_ID: lab.id,
            lab_name: lab.lab_name, // Add the lab name (A, B, C)
            reserved_by_user_id: adminUser.id, // Use the actual UUID from users table
            reserved_by: user_name, // Store the original name provided by admin (already validated)
            seat_ID: parseInt(seatNumber),
            seat_num: seat.seat_num // Use the seat_num directly from lab_seats table
            // created_at will be auto-generated by Supabase
        };

        console.log('Creating admin reservation with data:', newReservation);

        // Insert the reservation
        console.log('Inserting admin reservation into database...');
        const { data: insertedReservation, error: insertError } = await supabase
            .from('reservation')
            .insert([newReservation])
            .select();

        if (insertError) {
            console.error("Error inserting admin reservation:", insertError);
            console.error("Insert error details:", {
                code: insertError.code,
                message: insertError.message,
                details: insertError.details,
                hint: insertError.hint
            });
            return res.status(500).json({ message: "Error creating reservation" });
        }

        console.log('Admin reservation created successfully:', insertedReservation);
        
        // Note: We no longer update is_available in lab_seats table
        // Seat availability is now managed purely through the reservation table
        
        return res.status(201).json({ message: "Reservation successful" });
    } catch (e) {
        console.error("Error occurred while reserving seat:", e);
        return res.status(500).json({ message: "Internal server error" });
    }
};


// Define the route for deleting reservations
exports.deleteReservation = async (req, res) => {
    try {
        // Extract parameters from the request body
        const { lab_id, seatNumber, date, start_time, end_time, username } = req.body;

        // Query to find and delete the reservation
        const query = {
            date_of_reservation: date,
            start_time: start_time,
            end_time: end_time,
            lab_ID: lab_id,
            reserved_by_user_id: req.body.reserved_by,
            seat_ID: parseInt(seatNumber)
        }

        // Delete the reservation from the database
        const { error: deleteError } = await supabase
            .from('reservation')
            .delete()
            .match(query);

        if (deleteError) {
            console.error("Error deleting reservation:", deleteError);
            return res.status(500).json({ message: "Error deleting reservation" });
        }

        return res.status(200).json({ message: "Reservation deleted successfully" });
    } catch (error) {
        console.error("Error occurred while deleting reservation:", error);
        return res.status(500).json({ message: "Internal server error" });
    }
};



// Helper function to retrieve 
const retrieveReservation = async (labId, seatNumber, date, startTime, endTime, reservedBy, db) => {
    try {
        const reservationCollection = db.collection('reservation');

        // Construct the query based on the provided parameters
        const query = {
            "lab_id": labId,
            "seatNumber": seatNumber,
            "date": date,
            "start_time": startTime,
            "end_time": endTime,
            "reserved_by": reservedBy
        };

        // Execute the query to find the reservation
        const reservation = await reservationCollection.findOne(query);
        return reservation;
    } catch (error) {
        console.error('Error occurred while retrieving reservation:', error);
        throw error;
    }
};


function formatTime(hour) {
    // Ensure the hour is within the range of 0 to 23
    hour = Math.max(0, Math.min(23, hour));

    // Convert the hour to a string and pad with leading zero if necessary
    const hourStr = hour < 10 ? '0' + hour : String(hour);

    // Return the formatted time string
    return hourStr + ':00';
}



exports.updateReservationProfile = async (req, res) => {
    try {
        // Extract data from the request body
        let { newDate, newStart, newEndTime, labId, seatNumber, date, start_time, end_time, reserved_by } = req.body;

        // Construct the query based on the provided parameters
        const reservationQuery = {
            "lab_ID": labId,
            "seat_ID": parseInt(seatNumber),
            "date_of_reservation": date,
            "start_time": start_time,
            "end_time": end_time,
            "reserved_by_user_id": reserved_by
        };

        // Update the reservation with the new date and time
        const { error: updateError } = await supabase
            .from('reservation')
            .update({
                date_of_reservation: newDate,
                start_time: newStart,
                end_time: newEndTime
            })
            .match(reservationQuery);

        if (updateError) {
            console.error("Error updating reservation:", updateError);
            return res.status(500).json({ message: 'Error updating reservation' });
        }

        // Send a response indicating success
        res.status(200).json({ message: 'Reservation updated successfully' });
    } catch (error) {
        console.error('Error occurred while updating reservation:', error);
        res.status(500).json({ message: 'An error occurred while updating reservation. Please try again later.' });
    }
};

exports.deleteAllReservationsBasedOnUser = async (req, res) => {
    try {
        // Get the user ID from the session username
        const { data: user, error: userError } = await supabase
            .from('users')
            .select('id')
            .eq('username', req.session.username)
            .single();

        if (userError || !user) {
            console.error("Error finding user:", userError);
            return res.status(500).json({ message: 'Error finding user' });
        }

        // Delete all reservations associated with the user ID
        const { error: deleteError } = await supabase
            .from('reservation')
            .delete()
            .eq('reserved_by_user_id', user.id);

        if (deleteError) {
            console.error("Error deleting reservations:", deleteError);
            return res.status(500).json({ message: 'Error deleting reservations' });
        }

        // Respond with success message
        return res.status(200).json({ message: 'All reservations deleted successfully' });
    } catch (error) {
        console.error('Error occurred while deleting reservations:', error);
        // Respond with an error message
        return res.status(500).json({ message: 'Internal server error' });
    }
};


exports.deleteReservationFromLab = async (req, res) => {
    try {
        const { lab_name, seatNumber, date, start_time, end_time, username } = req.body;

        // Delete the reservation directly from the reservation table
        const { error: deleteError } = await supabase
            .from('reservation')
            .delete()
            .match({
                lab_ID: lab_name,
                seat_ID: parseInt(seatNumber),
                date_of_reservation: date,
                start_time: start_time,
                end_time: end_time,
                reserved_by_user_id: username
            });

        if (deleteError) {
            console.error("Error deleting reservation:", deleteError);
            return res.status(500).json({ message: "Error deleting reservation" });
        }

        return res.status(200).json({ message: "Reservation deleted successfully" });
    } catch (e) {
        console.error("Error occurred while deleting reservation:", e);
        return res.status(500).json({ message: "Internal server error" });
    }
}

// Function to check seat availability for a specific date and time
exports.checkSeatAvailability = async (req, res) => {
    try {
        const { date, start_time, end_time } = req.body;
        const labId = req.params.labName;

        if (!date || !start_time || !end_time) {
            return res.status(400).json({ message: "Date, start time, and end time are required" });
        }

        // First, get the lab by name to get its ID
        const { data: lab, error: labError } = await supabase
            .from('lab')
            .select('id')
            .eq('lab_name', labId)
            .single();

        if (labError || !lab) {
            console.error("Error finding lab:", labError);
            return res.status(404).json({ message: "Lab not found" });
        }

        // Get all seats for the lab using the lab ID (we only need id and seat_num)
        const { data: allSeats, error: seatsError } = await supabase
            .from('lab_seats')
            .select('id, seat_num')
            .eq('lab_ID', lab.id);

        if (seatsError) {
            console.error("Error fetching lab seats:", seatsError);
            return res.status(500).json({ message: "Error fetching lab seats" });
        }

        // Get all reservations for the lab on the specified date AND time slot (exact match)
        const { data: dateReservations, error: reservationsError } = await supabase
            .from('reservation')
            .select('seat_ID, reserved_by')
            .eq('lab_ID', lab.id)
            .eq('date_of_reservation', date)
            .eq('start_time', start_time)
            .eq('end_time', end_time);

        if (reservationsError) {
            console.error("Error checking date-based reservations:", reservationsError);
            return res.status(500).json({ message: "Error checking seat availability" });
        }

        // Get the IDs of reserved seats for this exact date and time slot
        const reservedSeatIds = dateReservations.map(res => res.seat_ID);

        // Get seats that are temporarily unavailable due to time-based reservations
        const temporarilyUnavailableSeats = allSeats.filter(seat => 
            reservedSeatIds.includes(seat.id)
        );

        // Get seats that are available (not reserved for this time slot)
        const availableSeats = allSeats.filter(seat => 
            !reservedSeatIds.includes(seat.id)
        );

        // Return the availability data
        const availabilityData = {
            availableSeats: availableSeats.map(seat => seat.id),
            reservedSeats: reservedSeatIds, // Only seats with reservations for this exact date/time
            totalSeats: allSeats.length,
            availableCount: availableSeats.length,
            reservedCount: reservedSeatIds.length
        };

        return res.status(200).json(availabilityData);

    } catch (error) {
        console.error("Error occurred while checking seat availability:", error);
        return res.status(500).json({ message: "Internal server error" });
    }
};

